?rnorm
help.search("rnorm")
args(rnorm)
rnorm(100)
set.seed(1)
rnorm(10)
?crystel
...
tittle: "Ejercicio MarkDown"
autor:
date:
output: html_document
...
Encabezado
# **Primer Nivel**
##*Segundo Nivel**
##Tercer nivel
clear
a<-available.packages()
head(rownames(a),3)
n<-signif(nrow(a),2)
n
install.packages("ggplot2")
source("http://bioconector.org/biocLite.R")
source("http://bioconductor.org/biocLite.R")
library(ggplot2)
require(ggplot2)
install.packages("RTools")
install.packages("devtools")
x <- 1
print(x)
msg <- "Hola"
msg
x <- ##Esto es un comentario
2
x <- 1:20
print()
print(x)
?vector
a <- vector(mode="numeric",length = 5)
1/3
1l/3
class(1)
class(1l)
class(1L)
1/0
0/0
attributes(airquality)
##clase del 25 de agosto
#crear vectores con la función vector
x <-vector(mode = "numeric", leght=5L)
x <- vector(mode = "numeric", length = 5L)
x
#crear vectores con la función c
x <- c(0.5,0.6)
x
class(x)
atributes(m)
x<-vector(mode = "numeric", length = 5L)
x
#crear vectores con la función c
x<- c(0.5,0.6)
x
class(x)
x<-c(TRUE ,FALSE ,T ,F)
x
class(x)
x<-10:0
x
class(x)
x<-c(1+2i,5,3+9i,-4-5i)
x
class(x)
x<-c("a","b","c","d")
x
class(x)
#mezcla de objetos en un vector
y<-c(1.7,"a") #caracter
y
class(y)
y<-c(TRUE,2) #numeric
y
class(y)
y<-c("a",TRUE) #caracter
y
class(y)
y<-c(TRUE,10L,8.5,1+i,"algo")
y<-c(TRUE,10L,8.5, 1 + i,"algo")
y
class(y)
#orden de coaccion/coerencion explicita
#1 character
#2 complex
#3 numeric
#4 integer
#5 logical
#coercion explicita
z<-0:6
class(z)
as.numeric(z)
as.logical(z)
as.character(z)
z<-c(1+2i,3+4i,8,0+3i,0)
as.logical(z)
z<-c("programacion"."actuaria","III")
as.numeric(z)
as.logical(z)
as.complex(z)
#listas (es como vector. pero de vectores y c/u tiene propia clase)
x<- list(1,"a","TRUE","1+4i")
x
class(x)
#Matrices
m<- matrix(nrow = 2,ncol = 3)
m
dim(m)
atributes(m)
x<- c(0.5,0.6)
m<- matrix(nrow = 2,ncol = 3)
m
dim(m)
atributes(m)
m<- matrix(nrow = 2,ncol = 3)
m
dim(m)
attributes(m)
m<- matrix(nrow = 2,ncol = 3)
m
dim(m)
attributes(m)
dim (m) <-c(3,2)
m
m<-matrix(1:6,3,2)
m
m
m
m<-matrix(1:6,3,3,TRUE)
m
class(m)
str(m)
dim(m)<-c(2,5)
x<-c(1,2,3)
y<-("a","b","c")
z<-c(x,y)
z
x<-c(1,2,3)
y<-("a","b","c")
z<-c(x,y)
z
x<-c(1,2,3)
y<-c("a","b","c")
z<-c(x,y)
z
m1<-rbind(m,x)
m1
m2
m3<-rbind(m,y)
m3
m2<-cbind(m,x)
m2
m1<-rbind(m,x)
m1
m2<-cbind(m,x)
m2
rbind(m1,y)
cbind(m2,y)
install.packages("rmarkdown")
install.packages("markdown")
getwd()
setwd("~/GitHub/Programacion_Actuarial_lll_OT2016")
data<-read.csv("datos s&p.csv")
data<-read.table("datos s&p.csv",T,",",nrows = 100)
data<-sapply(data, class)
data
view(data)
view(data)
y<-data.frame(a=1,b="a")
y<-data.frame(a=1,b="a")
dput(y)
y
nueva.y
nueva.y
x<-"Programación actuarial III"
y<-data.frame(a=1,b="a")
dump(C("x","y"),file = "data.R")
dput(y,file="y.R")
y
nueva.y ######No sale
dump(C("x","y"),file = "data.R")
x<-"Programación actuarial III"
y<-data.frame(a=1,b="a")
dump(C("x","y"),file = "data.R")
dump(C("x","y"),file = "data.R")
rm(x,y)
source("data.R")
x<-"Programación actuarial III"
y<-data.frame(a=1,b="a")
dump(c("x","y"),file = "data.R")
rm(x,y)
source("data.R")
head(airquality)
nueva.y ######No sale
x<-"Programación actuarial III"
y<-data.frame(a=1,b="a")
dump(c("x","y"),file = "data.R")
rm(x,y)
source("data.R")
nueva.y ######No sale
nueva.y<-dget("y.R")
nueva.y ######No sale
airquality<-data.frame(a=1,b="a")
dput(airquality)
dput(airquality,file="airquality.R")
airquality
con<-url("http://http://www.fcfm.buap.mx/","r")
con<-url("http://www.fcfm.buap.mx/","r")
x<-readLines(con,7)
x
#creamos un vector
x<-c("a","b","c","c","d","e")
#veamos el vector
x
#extraemos elementos con []
x[1]
x[2]
#también podemos extraer una secuencia de elementos
x[1:4]
#es posible extraerlos elementos que cumplen una restricción
x[x>"b"]
#de manera equivalente se puede obtener un vector lógico
#de manera equivalente se puede obtener un vector lógico
u<-x=="c"
u
x[u]
#creamos un vector
x<-c("a","b","c","d","e")
#veamos el vector
x
#extraemos elementos con []
x[1]
x[2]
#también podemos extraer una secuencia de elementos
x[1:4]
#es poible extraer los elementos que cumplen una restricción
x[x>"b"]
#de manera equivalente se puede obtener un vector lógico
u<-x=="c"
u
x[u]
x[1]
x[1]
#creamos una lista
x<-list(foo=1:4,bar=0.6)
#extraemos el primer elemento de la lista
#este elemento es una lista que contiene una secuencia
x[1]
también podemos
#creamos una lista
x<-list(foo=1:4,bar=0.6)
#extraemos el primer elemento de la lista
#este elemento es una lista que contiene una secuencia
x[1]
#extraemos nuevamente el primer elemento de la lista
#ahora el elemento es la secuencia en si
x[[1]]
#extraemos un elemento por nombre
x$bar
x[["bar"]]
x["bar"]
